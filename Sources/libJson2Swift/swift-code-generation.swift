//
//  swift-code-generation.swift
//  json2swift
//
//  Created by Joshua Smith on 10/14/16.
//  Copyright Â© 2016 iJoshSmith. All rights reserved.
//

import Foundation

// MARK: - SwiftCodeGenerator

struct SwiftCodeGenerator {
    // MARK: Internal

    /// This method is used when only one Swift file is being generated.
    static func generateCodeWithJSONUtilities(for swiftStruct: SwiftStruct) -> String {
        [
            preamble,
            "//",
            "// MARK: - Data Model",
            "//",
            swiftStruct.toSwiftCode(),
            "",
            "//",
            "// MARK: - JSON Utilities",
            "//",
            jsonUtilitiesTemplate,
            "",
        ].joined(separator: "\n")
    }

    /// This method is used when multiple Swift files are being generated.
    static func generateCode(for swiftStruct: SwiftStruct) -> String {
        [
            preamble,
            swiftStruct.toSwiftCode(),
            "",
        ].joined(separator: "\n")
    }

    /// This method is used to only create the JSON utility code once when multiple Swift files are being generated.
    static func generateJSONUtilities() -> String {
        [
            preamble,
            jsonUtilitiesTemplate,
            "",
        ].joined(separator: "\n")
    }

    // MARK: Private

    private static let preamble = [
        "// This file was generated by json2swift. https://github.com/ijoshsmith/json2swift",
        "",
        "import Foundation",
        "",
    ].joined(separator: "\n")
}

// MARK: - Implementation

public typealias SwiftCode = String
public typealias LineOfCode = SwiftCode

// MARK: - Indentation

private struct Indentation {
    // MARK: Lifecycle

    init(chars: String, level: Int = 0) {
        precondition(level >= 0)
        self.chars = chars
        self.level = level
        self.value = String(repeating: chars, count: level)
    }

    // MARK: Internal

    func apply(toLineOfCode lineOfCode: LineOfCode) -> LineOfCode {
        value + lineOfCode
    }

    func apply(
        toFirstLine firstLine: LineOfCode,
        nestedLines generateNestedLines: (Indentation) -> [LineOfCode],
        andLastLine lastLine: LineOfCode
    ) -> [LineOfCode] {
        let first = apply(toLineOfCode: firstLine)
        let middle = generateNestedLines(increased())
        let last = apply(toLineOfCode: lastLine)
        return [first] + middle + [last]
    }

    // MARK: Private

    private let chars: String
    private let level: Int
    private let value: String

    private func increased() -> Indentation {
        Indentation(chars: chars, level: level + 1)
    }
}

extension SwiftStruct {
    fileprivate func toSwiftCode(indentedBy indentChars: String = "    ") -> SwiftCode {
        let indentation = Indentation(chars: indentChars)
        let linesOfCode = toLinesOfCode(at: indentation)
        return linesOfCode.joined(separator: "\n")
    }

    private func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        indentation.apply(
            toFirstLine: "struct \(name): CreatableFromJSON {",
            nestedLines: linesOfCodeForMembers(at:),
            andLastLine: "}"
        )
    }

    private func linesOfCodeForMembers(at indentation: Indentation) -> [LineOfCode] {
        linesOfCodeForProperties(at: indentation)
            + initializer.toLinesOfCode(at: indentation)
            + failableInitializer.toLinesOfCode(at: indentation)
            + linesOfCodeForNestedStructs(at: indentation)
    }

    private func linesOfCodeForProperties(at indentation: Indentation) -> [LineOfCode] {
        sortedProperties.map { property in
            let propertyCode = property.toLineOfCode()
            return indentation.apply(toLineOfCode: propertyCode)
        }
    }

    private var sortedProperties: [SwiftProperty] {
        properties.sorted { lhs, rhs -> Bool in
            lhs.name.compare(rhs.name) == .orderedAscending
        }
    }

    private func linesOfCodeForNestedStructs(at indentation: Indentation) -> [LineOfCode] {
        sortedNestedStructs.flatMap { $0.toLinesOfCode(at: indentation) }
    }

    private var sortedNestedStructs: [SwiftStruct] {
        nestedStructs.sorted(by: { lhs, rhs -> Bool in
            lhs.name.compare(rhs.name) == .orderedAscending
        })
    }
}

extension SwiftType {
    fileprivate func toSwiftCode() -> SwiftCode {
        isOptional ? name + "?" : name
    }
}

extension SwiftProperty {
    fileprivate func toLineOfCode() -> LineOfCode {
        "let \(name): \(type.toSwiftCode())"
    }
}

extension SwiftParameter {
    fileprivate func toSwiftCode() -> SwiftCode {
        "\(name): \(type.toSwiftCode())"
    }
}

extension SwiftInitializer {
    fileprivate func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        indentation.apply(
            toFirstLine: "init(\(parameterList)) {",
            nestedLines: linesOfCodeForPropertyAssignments(at:),
            andLastLine: "}"
        )
    }

    private var parameterList: SwiftCode {
        sortedParameters
            .map { $0.toSwiftCode() }
            .joined(separator: ", ")
    }

    private func linesOfCodeForPropertyAssignments(at indentation: Indentation) -> [LineOfCode] {
        sortedParameters
            .map { "self.\($0.name) = \($0.name)" }
            .map(indentation.apply(toLineOfCode:))
    }

    private var sortedParameters: [SwiftParameter] {
        parameters.sorted { lhs, rhs -> Bool in
            lhs.name.compare(rhs.name) == .orderedAscending
        }
    }
}

extension SwiftFailableInitializer {
    fileprivate func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        indentation.apply(
            toFirstLine: "init?(json: [String: Any]) {",
            nestedLines: linesOfCodeInMethodBody(at:),
            andLastLine: "}"
        )
    }

    private func linesOfCodeInMethodBody(at indentation: Indentation) -> [LineOfCode] {
        let linesOfCode = linesOfCodeForTransformations + [lineOfCodeForCallingInitializer]
        return linesOfCode.map(indentation.apply(toLineOfCode:))
    }

    private var linesOfCodeForTransformations: [LineOfCode] {
        let requiredTransformationLines = sortedRequiredTransformations.map(\.guardedLetStatement)
        let optionalTransformationLines = sortedOptionalTransformations.map(\.letStatement)
        return (requiredTransformationLines + optionalTransformationLines)
    }

    private var lineOfCodeForCallingInitializer: LineOfCode {
        let sortedPropertyNames = (requiredTransformations + optionalTransformations).map(\.propertyName).sorted()
        let labeledArguments = sortedPropertyNames.map { $0 + ": " + $0 }
        let argumentList = labeledArguments.joined(separator: ", ")
        return "self.init(" + argumentList + ")"
    }

    private var sortedRequiredTransformations: [TransformationFromJSON] {
        sort(transformations: requiredTransformations)
    }

    private var sortedOptionalTransformations: [TransformationFromJSON] {
        sort(transformations: optionalTransformations)
    }

    private func sort(transformations: [TransformationFromJSON]) -> [TransformationFromJSON] {
        transformations.sorted { lhs, rhs -> Bool in
            lhs.propertyName.compare(rhs.propertyName) == .orderedAscending
        }
    }
}

// Internal for unit test access.
extension TransformationFromJSON {
    internal var propertyName: String {
        switch self {
        case let .toCustomStruct(_, propertyName, _): return propertyName
        case let .toPrimitiveValue(_, propertyName, _): return propertyName
        case let .toCustomStructArray(_, propertyName, _, _): return propertyName
        case let .toPrimitiveValueArray(_, propertyName, _, _): return propertyName
        }
    }

    internal var guardedLetStatement: LineOfCode {
        "guard \(letStatement) else { return nil }"
    }

    internal var letStatement: LineOfCode {
        switch self {
        case let .toCustomStruct(attributeName, propertyName, type): return TransformationFromJSON
            .letStatementForCustomStruct(attributeName, propertyName, type)
        case let .toPrimitiveValue(attributeName, propertyName, type): return TransformationFromJSON
            .letStatementForPrimitiveValue(attributeName, propertyName, type)
        case let .toCustomStructArray(
            attributeName,
            propertyName,
            elementType,
            hasOptionalElements
        ): return TransformationFromJSON.letStatementForCustomStructArray(
                attributeName,
                propertyName,
                elementType,
                hasOptionalElements
            )
        case let .toPrimitiveValueArray(
            attributeName,
            propertyName,
            elementType,
            hasOptionalElements
        ): return TransformationFromJSON.letStatementForPrimitiveValueArray(
                attributeName,
                propertyName,
                elementType,
                hasOptionalElements
            )
        }
    }

    private static func letStatementForCustomStruct(
        _ attributeName: String,
        _ propertyName: String,
        _ type: SwiftStruct
    )
        -> LineOfCode {
        "let \(propertyName) = \(type.name)(json: json, key: \"\(attributeName)\")"
    }

    private static func letStatementForPrimitiveValue(
        _ attributeName: String,
        _ propertyName: String,
        _ type: SwiftPrimitiveValueType
    )
        -> LineOfCode {
        switch type {
        case .any: return "let \(propertyName) = json[\"\(attributeName)\"] as? Any"
        case .emptyArray: return "let \(propertyName) = json[\"\(attributeName)\"] as? [Any?]"
        case .bool, .int, .string: return "let \(propertyName) = json[\"\(attributeName)\"] as? \(type.name)"
        case .double: return "let \(propertyName) = Double(json: json, key: \"\(attributeName)\")" // Allows an integer to be interpreted as a double.
        case .url: return "let \(propertyName) = URL(json: json, key: \"\(attributeName)\")"
        case let .date(format): return "let \(propertyName) = Date(json: json, key: \"\(attributeName)\", format: \"\(format)\")"
        }
    }

    private static func letStatementForCustomStructArray(
        _ attributeName: String,
        _ propertyName: String,
        _ elementType: SwiftStruct,
        _ hasOptionalElements: Bool
    )
        -> LineOfCode {
        hasOptionalElements
            ?
            "let \(propertyName) = \(elementType.name).createOptionalInstances(from: json, arrayKey: \"\(attributeName)\")"
            :
            "let \(propertyName) = \(elementType.name).createRequiredInstances(from: json, arrayKey: \"\(attributeName)\")"
    }

    private static func letStatementForPrimitiveValueArray(
        _ attributeName: String,
        _ propertyName: String,
        _ elementType: SwiftPrimitiveValueType,
        _ hasOptionalElements: Bool
    )
        -> LineOfCode {
        hasOptionalElements
            ? letStatementForArrayOfOptionalPrimitiveValues(attributeName, propertyName, elementType)
            : letStatementForArrayOfRequiredPrimitiveValues(attributeName, propertyName, elementType)
    }

    private static func letStatementForArrayOfOptionalPrimitiveValues(
        _ attributeName: String,
        _ propertyName: String,
        _ elementType: SwiftPrimitiveValueType
    )
        -> LineOfCode {
        switch elementType {
        case .any, .bool, .emptyArray, .int,
             .string: return "let \(propertyName) = (json[\"\(attributeName)\"] as? [Any]).map({ $0.toOptionalValueArray() as [\(elementType.name)?] })"
        case let .date(format): return "let \(propertyName) = (json[\"\(attributeName)\"] as? [Any]).map({ $0.toOptionalDateArray(withFormat: \"\(format)\") })"
        case .double: return "let \(propertyName) = (json[\"\(attributeName)\"] as? [Any]).map({ $0.toOptionalDoubleArray() })"
        case .url: return "let \(propertyName) = (json[\"\(attributeName)\"] as? [Any]).map({ $0.toOptionalURLArray() })"
        }
    }

    private static func letStatementForArrayOfRequiredPrimitiveValues(
        _ attributeName: String,
        _ propertyName: String,
        _ elementType: SwiftPrimitiveValueType
    )
        -> LineOfCode {
        switch elementType {
        case .any: return "let \(propertyName) = json[\"\(attributeName)\"] as? [Any?]" // Any is treated as optional.
        case .emptyArray: return "let \(propertyName) = json[\"\(attributeName)\"] as? [[Any?]]"
        case .bool, .int, .string: return "let \(propertyName) = json[\"\(attributeName)\"] as? [\(elementType.name)]"
        case let .date(format): return "let \(propertyName) = (json[\"\(attributeName)\"] as? [String]).flatMap({ $0.toDateArray(withFormat: \"\(format)\") })"
        case .double: return "let \(propertyName) = (json[\"\(attributeName)\"] as? [NSNumber]).map({ $0.toDoubleArray() })"
        case .url: return "let \(propertyName) = (json[\"\(attributeName)\"] as? [String]).flatMap({ $0.toURLArray() })"
        }
    }
}

extension SwiftPrimitiveValueType {
    fileprivate var name: String {
        switch self {
        case .any: return "Any"
        case .bool: return "Bool"
        case .date: return "Date"
        case .double: return "Double"
        case .emptyArray: return "[Any?]"
        case .int: return "Int"
        case .string: return "String"
        case .url: return "URL"
        }
    }
}
